{
  "name": "Duktio",
  "tagline": "Microservices, webscripts for IoT, open data, and much more.",
  "body": "# DUKTio\r\nMicroservices, webscripts for IoT, open data, and much more.\r\nPublic version running at http://www.dukt.io\r\n\r\n## Install instructions\r\n+ Setup the system domain == an account tied to the \"system\" domain that contains the Lua code that allows to customize the internal handling of the messages, i.e. routing and bridges (http and mqtt) \r\n    + Make an account on your Dukt server\r\n    + Go to profile and set the subdomain field to \"system\"\r\n    + Go to Duks and add the following nodes (leave path, input and output ports blank):\r\n        + click New Dukt:\r\n            + name: ```router```\r\n            + code: \r\n                ```\r\n                print (\"In system.router\")\r\n                pretty.dump(message)\r\n                \r\n                -- Get the sender info\r\n                local routing_from = message.routing.from\r\n                -- local subdomain, dukt, direction, port = unpack(utils.split(routing_from,\".\", 1))\r\n                \r\n                -- Get the endpoints\r\n                local query = '{_id: \"' .. message.routing.from .. '\"}'\r\n                local edges = assert(mongo_conn:query('meteor.edges', query))\r\n                local endpoints = edges:next().endpoints\r\n                pretty.dump(endpoints)\r\n                \r\n                -- Push 1 message for each endpoint to the worker queue\r\n                for k,endpoint in pairs(endpoints) do\r\n                  print(\"In endpoint \" .. endpoint)\r\n                  message.routing.to = endpoint\r\n                  redis_conn:rpush(\"message_list\", cjson.encode(message))\r\n                end\r\n                print (\"Leaving system.router\")\r\n                return \"ok\"\r\n                ```\r\n        + click New Dukt:\r\n            + name: ```http```\r\n            + code: \r\n                ```\r\n                print (\"***** Entering system.http\")\r\n                -- console(pretty.write(message))\r\n                \r\n                -- Get the routing info for the user msg\r\n                local subdomain = message.msg.subdomain\r\n                local pathname = message.msg.pathname\r\n                -- pathname = string.sub(pathname, 1)\r\n                message.routing = {}\r\n                \r\n                -- Get the endpoints\r\n                -- local query = '{_id: \"httprequest|' .. subdomain ..'.' .. pathname .. '\"}'   \r\n                local query = '{\"subdomain\": \"' .. subdomain .. '\" , \"pathname\": \"' .. pathname .. '\"}'   -- TODO: Add security\r\n                -- console (\"Query: \" .. query)\r\n                local duks = assert(mongo_conn:query('meteor.duks', query)):results()\r\n                -- pretty.dump(duks)\r\n                \r\n                -- Push 1 message for each dukt to the worker queue\r\n                for duk in duks do\r\n                  -- console(\"In system.http: queueing msg to duk \" .. duk.name)\r\n                  message.routing.to = subdomain .. \".\" .. duk.name .. \".in.\" .. pathname\r\n                  redis_conn:rpush(\"message_list\", cjson.encode(message))\r\n                end\r\n                print (\"***** Leaving system.http\")\r\n                return \"OK\"\r\n                ```\r\n        + click New Dukt:\r\n            + name: ```mqtt```\r\n            + code: \r\n                ```\r\n                -- This dukt loops over all subscribers and sends them the message\r\n                print (\"***** Entering system.mqtt\")\r\n                -- pretty.dump(message)\r\n                \r\n                -- Get the routing info for the user msg\r\n                console(pretty.write(message))\r\n                \r\n                local subdomain = message.msg.subdomain\r\n                local pathname = message.msg.pathname\r\n                pathname = string.sub(pathname, 1)\r\n                message.routing = {}\r\n                \r\n                -- Get the endpoints\r\n                -- local query = '{_id: \"httprequest|' .. subdomain ..'.' .. pathname .. '\"}'   \r\n                local query = '{\"subdomain\": \"' .. subdomain .. '\" , \"pathname\": \"' .. pathname .. '\"}'   -- TODO: Add security\r\n                -- print (\"Query: \" .. query)\r\n                local duks = assert(mongo_conn:query('meteor.duks', query)):results()\r\n                -- pretty.dump(duks)\r\n                \r\n                -- make it that the user knows whether it's an publish or subscribe\r\n                if message.routing == \"system.mqtt.in.mqttpublish\" then\r\n                  message.msg.action = \"publish\"\r\n                elseif message.routing == \"system.mqtt.in.mqttsubscribe\" then\r\n                  message.msg.action = \"subscribe\"  \r\n                end\r\n                \r\n                -- Push 1 message for each dukt to the worker queue\r\n                for duk in duks do\r\n                  print(\"In system.http: queueing msg to duk \" .. duk.name)\r\n                  message.routing.to = subdomain .. \".\" .. duk.name .. \".in.\" .. pathname\r\n                  redis_conn:rpush(\"message_list\", cjson.encode(message))\r\n                end\r\n                \r\n                print (\"***** Leaving system.mqtt\")\r\n                return \"OK\"\r\n                ```    \r\n                \r\n## TODOS\r\n\r\n+ Install instructions\r\n    + nginx setup\r\n+ Describe architecture\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}